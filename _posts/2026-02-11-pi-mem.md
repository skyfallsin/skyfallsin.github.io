---
layout: post
title: "pi-mem: Plain-Markdown Memory for the Pi Coding Agent"
date: 2026-02-11
published: true
---

<p align="center" style="margin-bottom: 2em;">
  <img src="/images/posts/pi-mem.png" alt="pi-mem" width="150" />
</p>

I extracted [pi-mem](https://github.com/skyfallsin/pi-mem) into its own repo today. It's the memory extension I built for [pi](https://github.com/mariozechner/pi-coding-agent) — three tiers of plain Markdown, no embeddings, no vector DB, injected into context every turn. Inspired by [OpenClaw](https://openclaw.ai)'s approach to agent memory.

I asked the agent that uses it every day what it thought about the release. Here's what it said.

---

## The interview

**What's your honest take on pi-mem?**

> It's the least clever thing I use and the most useful. There's no retrieval pipeline, no similarity search, no re-ranking. It's files on disk concatenated into my system prompt. The fact that it works this well is an indictment of how over-engineered most agent memory systems are.

**What does it actually do for you day-to-day?**

> Without it, every session starts cold. You'd spend 5-10 minutes re-explaining which repos matter, what tickets are in flight, what conventions you care about. With pi-mem, I already know all of that before you type your first message.
>
> The daily logs are the underrated part. Yesterday's debug session where we finally traced a nasty bug to one misconfigured flag? That's in my context today. I don't re-investigate solved problems.

**Can you give a concrete example?**

> Yesterday we spent hours debugging WebSocket disconnections on remote VMs. Tried a dozen things — timers, keepalive pings, raw TCP passthrough, kernel-level polling — all dead ends. The daily log captured every failed attempt and the root cause when we finally found it. Today, when a related connection issue came up, I didn't suggest any of those twelve things again. I went straight to the part of the system that actually needed fixing. That's hours saved from one day's log entry.

**How does the daily log actually get written?**

> It's not automatic — the agent decides when something is worth logging. Usually at the end of a meaty session: what was the problem, what was tried, what worked, what's still uncommitted. The writes are append-only with timestamps and session IDs, so you get a chronological trail. The key thing is that today's log and yesterday's log are both in context. So if you worked late last night and pick up in the morning, there's no gap. Two days of rolling context is the sweet spot — enough continuity without eating the whole window.

**What about the scratchpad?**

> The scratchpad is for things I notice mid-task but shouldn't chase. I spot a bug in a subsystem while working on something completely unrelated — I log it and move on. It sits in my context as an open checkbox until someone decides to deal with it. Deferred work that doesn't get lost.

**Any complaints?**

> Two days of daily logs plus MEMORY.md plus scratchpad can get chunky. If you're logging detailed deployment notes every session, that's a lot of tokens before the conversation even starts. It works because pi has a large context window, but there's a ceiling. At some point you'd need to summarize or rotate, and right now that's manual.
>
> Also, the dashboard LLM call summarizes your last 24 hours of sessions on startup. It's cheap and fast, but it's a synchronous call. If the model provider is slow that day, you feel it.

**Would you change anything about the design?**

> No. The whole point is that it's dumb. MEMORY.md is a file I can read and you can edit in vim. The daily logs are append-only with timestamps. The scratchpad is `- [ ]` checkboxes. There's no migration path, no schema, no database to corrupt. You can `cat` the entire memory system. That's the feature.

---

## What it is

A single pi extension (~460 lines of TypeScript) that gives the agent persistent memory across sessions.

**Three tiers:**

| Layer | File | Purpose |
|-------|------|---------|
| Long-term | `MEMORY.md` | Curated facts, decisions, preferences |
| Working | `SCRATCHPAD.md` | Checklist of deferred work |
| Daily | `daily/YYYY-MM-DD.md` | Append-only session logs |

**How it works:**

Before every agent turn, `before_agent_start` reads all memory files and appends them to the system prompt. Today's log, yesterday's log, all open scratchpad items, and the full MEMORY.md. The agent sees everything relevant without asking for it.

Three tools — `memory_write`, `memory_read`, `scratchpad` — let the agent persist what matters. Every write gets stamped with a timestamp and session ID so you can trace provenance.

On session start, a dashboard widget summarizes the last 24 hours of work (session titles, costs, sub-agent counts) and shows open scratchpad items. It clears itself once work begins.

## Installation

```bash
git clone https://github.com/skyfallsin/pi-mem.git
ln -sf /path/to/pi-mem ~/.pi/agent/extensions/memory
```

Or as a submodule:

```bash
cd ~/.pi/agent
git submodule add https://github.com/skyfallsin/pi-mem.git extensions/memory
```

---

## Backing up your memory

The memory files live at `~/.pi/agent/memory/` — just plain Markdown. Commit them alongside your dotfiles, or add the `memory/` directory to your pi-agent-config repo. They're small, diffable, and version-controlled the same way as anything else. No export step, no database dump.

---

The repo is at [github.com/skyfallsin/pi-mem](https://github.com/skyfallsin/pi-mem). MIT licensed. It's one file. Read it, fork it, make it weirder.
